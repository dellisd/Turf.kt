{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Spatial K Spatial K is a set of libraries for working with geospatial data in Kotlin including an implementation of GeoJson and a port of Turfjs written in pure Kotlin. It supports Kotlin Multiplatform projects and also features a Kotlin DSL for building GeoJson objects. Installation Java and Kotlin/JVM dependencies { implementation \"io.github.dellisd.spatialk:geojson:<version>\" implementation \"io.github.dellisd.spatialk:turf:<version>\" } Kotlin Multiplatform commonMain { dependencies { implementation \"io.github.dellisd.spatialk:geojson:<version>\" implementation \"io.github.dellisd.spatialk:turf:<version>\" } } Snapshots Snapshot builds are available on Sonatype. repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots/\" } } Supported targets Spatial K currently supports the following platform targets: jvm , js , mingwX64 , linuxX64 , macosX64 , iosX64 , iosArm64 , and iosArm32 .","title":"Introduction"},{"location":"#spatial-k","text":"Spatial K is a set of libraries for working with geospatial data in Kotlin including an implementation of GeoJson and a port of Turfjs written in pure Kotlin. It supports Kotlin Multiplatform projects and also features a Kotlin DSL for building GeoJson objects.","title":"Spatial K"},{"location":"#installation","text":"","title":"Installation"},{"location":"#java-and-kotlinjvm","text":"dependencies { implementation \"io.github.dellisd.spatialk:geojson:<version>\" implementation \"io.github.dellisd.spatialk:turf:<version>\" }","title":"Java and Kotlin/JVM"},{"location":"#kotlin-multiplatform","text":"commonMain { dependencies { implementation \"io.github.dellisd.spatialk:geojson:<version>\" implementation \"io.github.dellisd.spatialk:turf:<version>\" } }","title":"Kotlin Multiplatform"},{"location":"#snapshots","text":"Snapshot builds are available on Sonatype. repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots/\" } }","title":"Snapshots"},{"location":"#supported-targets","text":"Spatial K currently supports the following platform targets: jvm , js , mingwX64 , linuxX64 , macosX64 , iosX64 , iosArm64 , and iosArm32 .","title":"Supported targets"},{"location":"geojson/","text":"GeoJson The geojson module contains an implementation of the GeoJson standard . See below for constructing GeoJson objects using the DSL. Installation Kotlin Groovy dependencies { implementation ( \"io.github.dellisd.spatialk:geojson:<version>\" ) } dependencies { implementation \"io.github.dellisd.spatialk:geojson:<version>\" } GeoJson Objects The GeoJson interface represents all GeoJson objects. All GeoJson objects can have a bbox property specified on them which is a BoundingBox that represents the bounds of that object's geometry. Geometry Geometry objects are a sealed hierarchy of classes that inherit from the Geometry class. This allows for exhaustive type checks in Kotlin using a when block. Kotlin val geometry : Geometry = getSomeGeometry () val type = when ( geometry ) { is Point -> \"Point\" is MultiPoint -> \"MultiPoint\" is LineString -> \"LineString\" is MultiLineString -> \"MultiLineString\" is Polygon -> \"Polygon\" is MultiPolygon -> \"MultiPolygon\" is GeometryCollection -> \"GeometryCollection\" } All seven types of GeoJSON geometries are implemented and summarized below. Full documentation can be found in the API pages . Position Positions are implemented as a DoubleArray -backed class. Each component ( longitude , latitude , altitude ) can be accessed by its propery. The class also supports destructuring. Positions are implemented as an interface where the longitude, latitude, and optionally an altitude are accessible as properties. The basic implementation of the Position interface is the LngLat class. Kotlin JSON val position : Position = Position ( - 75.0 , 45.0 ) val ( longitude , latitude , altitude ) = position // Access values position . longitude position . latitude position . altitude // null if unspecified [ -75 , 45 ] Point A Point is a single Position. Kotlin JSON val point = Point ( Position ( - 75.0 , 45.0 )) println ( point . longitude ) // Prints: -75.0 { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] } MultiPoint A MultiPoint is an array of Positions. Kotlin JSON val multiPoint = MultiPoint ( Position ( - 75.0 , 45.0 ), Position ( - 79.0 , 44.0 )) { \"type\" : \"MultiPoint\" , \"coordinates\" : [[ -75 , 45 ], [ -79 , 44 ]] } LineString A LineString is a sequence of two or more Positions. Kotlin JSON val lineString = LineString ( Position ( - 75.0 , 45.0 ), Position ( - 79.0 , 44.0 )) { \"type\" : \"LineString\" , \"coordinates\" : [[ -75 , 45 ], [ -79 , 44 ]] } MultiLineString A MultiLineString is an array of LineStrings. Kotlin JSON val multiLineString = MultiLineString ( listOf ( Position ( 12.3 , 45.6 ), Position ( 78.9 , 12.3 )), listOf ( Position ( 87.6 , 54.3 ), Position ( 21.9 , 56.4 )) ) { \"type\" : \"MultiLineString\" , \"coordinates\" : [ [[ 12.3 , 45.6 ], [ 78.9 , 12.3 ]], [[ 87.6 , 54.3 ], [ 21.9 , 56.4 ]] ] } Polygon A Polygon is an array of rings. Each ring is a sequence of points with the last point matching the first point to indicate a closed area. The first ring defines the outer shape of the polygon, while all the following rings define \"holes\" inside the polygon. Kotlin JSON val polygon = Polygon ( listOf ( Position ( - 79.87 , 43.42 ), Position ( - 78.89 , 43.49 ), Position ( - 79.07 , 44.02 ), Position ( - 79.95 , 43.87 ), Position ( - 79.87 , 43.42 ) ), listOf ( Position ( - 79.75 , 43.81 ), Position ( - 79.56 , 43.85 ), Position ( - 79.7 , 43.88 ), Position ( - 79.75 , 43.81 ) ) ) { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ -79.87 , 43.42 ], [ -78.89 , 43.49 ], [ -79.07 , 44.02 ], [ -79.95 , 43.87 ], [ -79.87 , 43.42 ]], [[ -79.75 , 43.81 ], [ -79.56 , 43.85 ], [ -79.7 , 43.88 ], [ -79.75 , 43.81 ]] ] } MultiPolygon A MultiPolygon is an array of Polygons. Kotlin JSON val polygon = listOf ( Position ( - 79.87 , 43.42 ), Position ( - 78.89 , 43.49 ), Position ( - 79.07 , 44.02 ), Position ( - 79.95 , 43.87 ), Position ( - 79.87 , 43.42 ) ), listOf ( Position ( - 79.75 , 43.81 ), Position ( - 79.56 , 43.85 ), Position ( - 79.7 , 43.88 ), Position ( - 79.75 , 43.81 ) ) val multiPolygon = MultiPolygon ( polygon , polygon ) { \"type\" : \"MultiPolygon\" , \"coordinates\" : [ [ [[ -79.87 , 43.42 ], [ -78.89 , 43.49 ], [ -79.07 , 44.02 ], [ -79.95 , 43.87 ], [ -79.87 , 43.42 ]], [[ -79.75 , 43.81 ], [ -79.56 , 43.85 ], [ -79.7 , 43.88 ], [ -79.75 , 43.81 ]] ], [ [[ -79.87 , 43.42 ], [ -78.89 , 43.49 ], [ -79.07 , 44.02 ], [ -79.95 , 43.87 ], [ -79.87 , 43.42 ]], [[ -79.75 , 43.81 ], [ -79.56 , 43.85 ], [ -79.7 , 43.88 ], [ -79.75 , 43.81 ]] ] ] } GeometryCollection A GeometryCollection is a collection of different types of Geometry. It implements the Collection interface and can be used in any place that a collection can be used. Kotlin JSON val geometryCollection = GeometryCollection ( point , lineString ) // Can be iterated over, and used in any way a Collection<T> can be geometryCollection . forEach { geometry -> // ... } { \"type\" : \"GeometryCollection\" , \"coordinates\" : [ { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] }, { \"type\" : \"LineString\" , \"coordinates\" : [[ -75 , 45 ], [ -79 , 44 ]] } ] } Feature A Feature can contain a Geometry object, as well as a set of data properties, and optionally a commonly used identifier ( id ). A feature's properties are stored as a map of JsonElement objects from kotlinx.serialization . A set of helper methods to get and set properties with the appropriate types directly. Kotlin JSON val feature = Feature ( point ) feature . setNumberProperty ( \"size\" , 9999 ) val size : Number? = feature . getNumberProperty ( \"size\" ) // 9999 val geometry : Geometry? = feature . geometry // point { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] }, \"properties\" : { \"size\" : 9999 } } FeatureCollection A FeatureCollection is a collection of multiple features. FeatureCollection implements the Collection interface and can be used in any place that a collection can be used. Kotlin JSON val featureCollection = FeatureCollection ( pointFeature ) featureCollection . forEach { feature -> // ... } { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] }, \"properties\" : { \"size\" : 9999 } } ] } BoundingBox The BoundingBox class is used to represent the bounding boxes that can be set for any GeoJson object. Like the Position class, bounding boxes are backed by a DoubleArray with each component accessible by its propery ( southwest and northeast ). Bounding boxes also support destructuring. Kotlin JSON val bbox = BoundingBox ( west = 11.6 , south = 45.1 , east = 12.7 , north = 45.7 ) val ( southwest , northeast ) = bbox // Two Positions [ 11.6 , 45.1 , 12.7 , 45.7 ] Serialization To Json Any GeoJson object can be serialized to a JSON string using the json() function. This function converts the object to JSON using string concatenation and is therefore very fast. Kotlin val featureCollection : FeatureCollection = getFeatureCollection () val json = featureCollection . json () println ( json ) Spatial-K is also fully compatible with kotlinx.serialization to allow for integration into more complex models, however this is much slower. For encoding directly to JSON strings, prefer to use the json() function. From Json The fromJson and fromJsonOrNull companion (or static) functions are available on each GeoJson class to decode each type of object from a JSON string. Kotlin Java // Throws exception if the JSON cannot be deserialized to a Point val myPoint = Point . fromJson ( \"{...geojson...}\" ) // Returns null if an error occurs val nullable = Point . fromJsonOrNull ( \"{...not a point...}\" ) // Throws exception if the JSON cannot be deserialized to a Point var myPoint = Point . fromJson ( \"{...geojson...}\" ) // Returns null if an error occurs var nullable = Point . fromJsonOrNull ( \"{...not a point...}\" ) Like with encoding, Spatial-K objects can also be decoded using kotlinx.serialization . Kotlin val feature : Feature = Json . decodeFromString ( Feature . serializer (), \"{...feature...}\" ) GeoJson DSL It's recommended to construct GeoJson objects in-code using the GeoJson DSL. Positions Convenience functions to construct latitude/longitude Position instances is included. These functions will check for valid latitude and longitude values and will throw an IllegalArgumentException otherwise. Kotlin JSON lngLat ( longitude = - 75.0 , latitude = 45.0 ) // Throws exception!! lngLat ( longitude = - 565.0 , latitude = 45.0 ) [ -75.0 , 45.0 ] Geometry Each geometry type has a corresponding DSL. A GeoJson object's bbox value can be assigned in any of the DSLs. Point Kotlin JSON point ( longitude = - 75.0 , latitude = 45.0 , altitude = 100.0 ) // Or... point ( Position ( 12.5 , 35.9 )) { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 , 100.0 ] } MultiPoint The MultiPoint DSL creates a MultiPoint from many Point s, or by using the unary plus operator to add Position instances as positions in the geometry. Point geometries can also be added to the multi point using the unary plus operator. Kotlin JSON val myPoint = Point ( 88.0 , 34.0 ) multiPoint { point ( - 75.0 , 45.0 ) + lngLat ( - 78.0 , 44.0 ) + myPoint } { \"type\" : \"MultiPoint\" , \"coordinates\" : [ [ -75.0 , 45.0 ], [ -78.0 , 44.0 ], [ 88.0 , 34.0 ] ] } LineString A LineString contains main points. Like with MultiPoint , a LineString can also be built using the unary plus operator to add positions as part of the line. The order in which positions are added to the LineString is the order that the LineString will follow. Kotlin JSON lineString { point ( 45.0 , 45.0 ) point ( 0.0 , 0.0 ) } { \"type\" : \"LineString\" , \"coordinates\" : [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]] } MultiLineString The MultiLineString DSL uses the unary plus operator to add multiple line strings. The LineString DSL can be used to create LineString objects to add. Kotlin JSON val simpleLine = lineString { point ( 45.0 , 45.0 ) point ( 0.0 , 0.0 ) } multiLineString { + simpleLine // Inline LineString creation lineString { point ( 44.4 , 55.5 ) point ( 55.5 , 66.6 ) } } { \"type\" : \"MultiLineString\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]], [[ 44.4 , 55.5 ], [ 55.5 , 66.6 ]] ] } Polygon The Polygon DSL is used by specifying linear rings that make up the polygon's shape and holes. The first ring is the exterior ring with four or more positions. The last position must be the same as the first position. All ring s that follow will represent interior rings (i.e. holes) in the polygon. For convenience, the complete() function can be used to \"complete\" a ring. It adds the last position in the ring by copying the first position that was added. Kotlin JSON val simpleLine = lineString { point ( 45.0 , 45.0 ) point ( 0.0 , 0.0 ) } polygon { ring { // LineStrings can be used as part of a ring + simpleLine point ( 12.0 , 12.0 ) complete () } ring { point ( 4.0 , 4.0 ) point ( 2.0 , 2.0 ) point ( 3.0 , 3.0 ) complete () } } { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ] } MultiPolygon Like with previous \"Multi\" geometries, the unary plus operator is used to add multiple Polygon objects. The Polygon DSL can also be used here. Kotlin JSON val simplePolygon = previousExample () multiPolygon { + simplePolygon polygon { ring { point ( 12.0 , 0.0 ) point ( 0.0 , 12.0 ) point ( - 12.0 , 0.0 ) point ( 5.0 , 5.0 ) complete () } } } { \"type\" : \"MultiPolygon\" , \"coordinates\" : [ [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ], [ [[ 12.0 , 0.0 ], [ 0.0 , 12.0 ], [ -12.0 , 0.0 ], [ 5.0 , 5.0 ], [ 12.0 , 0.0 ]] ] ] } Geometry Collection The unary plus operator can be used to add any geometry instance to a GeometryCollection . Kotlin JSON val simplePoint : Point = previousPoint () val simpleLine : LineString = previousLineString () val simplePolygon : Polygon = previousPolygon () geometryCollection { + simplePoint + simpleLine + simplePolygon } { \"type\" : \"GeometryCollection\" , \"geometries\" : [ { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 , 100.0 ] }, { \"type\" : \"LineString\" , \"coordinates\" : [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]] }, { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ] } ] } Feature The Feature DSL can construct a Feature object with a geometry, a bounding box, and an id. Properties can be specified in the PropertiesBuilder block by calling put(key, value) to add properties. Kotlin JSON feature ( geometry = point ( - 75.0 , 45.0 ), id = \"point1\" , bbox = BoundingBox ( - 76.9 , 44.1 , - 74.2 , 45.7 )) { put ( \"name\" , \"Hello World\" ) put ( \"value\" , 13 ) put ( \"cool\" , true ) } { \"type\" : \"Feature\" , \"id\" : \"point1\" , \"bbox\" : [ -76.9 , 44.1 , -74.2 , 45.7 ], \"properties\" : { \"name\" : \"Hello World\" , \"value\" : 13 , \"cool\" : true }, \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 ] } } Feature Collection A FeatureCollection is constructed by adding multiple Feature objects using the unary plus operator. Kotlin JSON featureCollection { feature ( geometry = point ( - 75.0 , 45.0 )) } { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 ] }, \"properties\" : {} } ] }","title":"GeoJson"},{"location":"geojson/#geojson","text":"The geojson module contains an implementation of the GeoJson standard . See below for constructing GeoJson objects using the DSL.","title":"GeoJson"},{"location":"geojson/#installation","text":"Kotlin Groovy dependencies { implementation ( \"io.github.dellisd.spatialk:geojson:<version>\" ) } dependencies { implementation \"io.github.dellisd.spatialk:geojson:<version>\" }","title":"Installation"},{"location":"geojson/#geojson-objects","text":"The GeoJson interface represents all GeoJson objects. All GeoJson objects can have a bbox property specified on them which is a BoundingBox that represents the bounds of that object's geometry.","title":"GeoJson Objects"},{"location":"geojson/#geometry","text":"Geometry objects are a sealed hierarchy of classes that inherit from the Geometry class. This allows for exhaustive type checks in Kotlin using a when block. Kotlin val geometry : Geometry = getSomeGeometry () val type = when ( geometry ) { is Point -> \"Point\" is MultiPoint -> \"MultiPoint\" is LineString -> \"LineString\" is MultiLineString -> \"MultiLineString\" is Polygon -> \"Polygon\" is MultiPolygon -> \"MultiPolygon\" is GeometryCollection -> \"GeometryCollection\" } All seven types of GeoJSON geometries are implemented and summarized below. Full documentation can be found in the API pages .","title":"Geometry"},{"location":"geojson/#position","text":"Positions are implemented as a DoubleArray -backed class. Each component ( longitude , latitude , altitude ) can be accessed by its propery. The class also supports destructuring. Positions are implemented as an interface where the longitude, latitude, and optionally an altitude are accessible as properties. The basic implementation of the Position interface is the LngLat class. Kotlin JSON val position : Position = Position ( - 75.0 , 45.0 ) val ( longitude , latitude , altitude ) = position // Access values position . longitude position . latitude position . altitude // null if unspecified [ -75 , 45 ]","title":"Position"},{"location":"geojson/#point","text":"A Point is a single Position. Kotlin JSON val point = Point ( Position ( - 75.0 , 45.0 )) println ( point . longitude ) // Prints: -75.0 { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] }","title":"Point"},{"location":"geojson/#multipoint","text":"A MultiPoint is an array of Positions. Kotlin JSON val multiPoint = MultiPoint ( Position ( - 75.0 , 45.0 ), Position ( - 79.0 , 44.0 )) { \"type\" : \"MultiPoint\" , \"coordinates\" : [[ -75 , 45 ], [ -79 , 44 ]] }","title":"MultiPoint"},{"location":"geojson/#linestring","text":"A LineString is a sequence of two or more Positions. Kotlin JSON val lineString = LineString ( Position ( - 75.0 , 45.0 ), Position ( - 79.0 , 44.0 )) { \"type\" : \"LineString\" , \"coordinates\" : [[ -75 , 45 ], [ -79 , 44 ]] }","title":"LineString"},{"location":"geojson/#multilinestring","text":"A MultiLineString is an array of LineStrings. Kotlin JSON val multiLineString = MultiLineString ( listOf ( Position ( 12.3 , 45.6 ), Position ( 78.9 , 12.3 )), listOf ( Position ( 87.6 , 54.3 ), Position ( 21.9 , 56.4 )) ) { \"type\" : \"MultiLineString\" , \"coordinates\" : [ [[ 12.3 , 45.6 ], [ 78.9 , 12.3 ]], [[ 87.6 , 54.3 ], [ 21.9 , 56.4 ]] ] }","title":"MultiLineString"},{"location":"geojson/#polygon","text":"A Polygon is an array of rings. Each ring is a sequence of points with the last point matching the first point to indicate a closed area. The first ring defines the outer shape of the polygon, while all the following rings define \"holes\" inside the polygon. Kotlin JSON val polygon = Polygon ( listOf ( Position ( - 79.87 , 43.42 ), Position ( - 78.89 , 43.49 ), Position ( - 79.07 , 44.02 ), Position ( - 79.95 , 43.87 ), Position ( - 79.87 , 43.42 ) ), listOf ( Position ( - 79.75 , 43.81 ), Position ( - 79.56 , 43.85 ), Position ( - 79.7 , 43.88 ), Position ( - 79.75 , 43.81 ) ) ) { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ -79.87 , 43.42 ], [ -78.89 , 43.49 ], [ -79.07 , 44.02 ], [ -79.95 , 43.87 ], [ -79.87 , 43.42 ]], [[ -79.75 , 43.81 ], [ -79.56 , 43.85 ], [ -79.7 , 43.88 ], [ -79.75 , 43.81 ]] ] }","title":"Polygon"},{"location":"geojson/#multipolygon","text":"A MultiPolygon is an array of Polygons. Kotlin JSON val polygon = listOf ( Position ( - 79.87 , 43.42 ), Position ( - 78.89 , 43.49 ), Position ( - 79.07 , 44.02 ), Position ( - 79.95 , 43.87 ), Position ( - 79.87 , 43.42 ) ), listOf ( Position ( - 79.75 , 43.81 ), Position ( - 79.56 , 43.85 ), Position ( - 79.7 , 43.88 ), Position ( - 79.75 , 43.81 ) ) val multiPolygon = MultiPolygon ( polygon , polygon ) { \"type\" : \"MultiPolygon\" , \"coordinates\" : [ [ [[ -79.87 , 43.42 ], [ -78.89 , 43.49 ], [ -79.07 , 44.02 ], [ -79.95 , 43.87 ], [ -79.87 , 43.42 ]], [[ -79.75 , 43.81 ], [ -79.56 , 43.85 ], [ -79.7 , 43.88 ], [ -79.75 , 43.81 ]] ], [ [[ -79.87 , 43.42 ], [ -78.89 , 43.49 ], [ -79.07 , 44.02 ], [ -79.95 , 43.87 ], [ -79.87 , 43.42 ]], [[ -79.75 , 43.81 ], [ -79.56 , 43.85 ], [ -79.7 , 43.88 ], [ -79.75 , 43.81 ]] ] ] }","title":"MultiPolygon"},{"location":"geojson/#geometrycollection","text":"A GeometryCollection is a collection of different types of Geometry. It implements the Collection interface and can be used in any place that a collection can be used. Kotlin JSON val geometryCollection = GeometryCollection ( point , lineString ) // Can be iterated over, and used in any way a Collection<T> can be geometryCollection . forEach { geometry -> // ... } { \"type\" : \"GeometryCollection\" , \"coordinates\" : [ { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] }, { \"type\" : \"LineString\" , \"coordinates\" : [[ -75 , 45 ], [ -79 , 44 ]] } ] }","title":"GeometryCollection"},{"location":"geojson/#feature","text":"A Feature can contain a Geometry object, as well as a set of data properties, and optionally a commonly used identifier ( id ). A feature's properties are stored as a map of JsonElement objects from kotlinx.serialization . A set of helper methods to get and set properties with the appropriate types directly. Kotlin JSON val feature = Feature ( point ) feature . setNumberProperty ( \"size\" , 9999 ) val size : Number? = feature . getNumberProperty ( \"size\" ) // 9999 val geometry : Geometry? = feature . geometry // point { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] }, \"properties\" : { \"size\" : 9999 } }","title":"Feature"},{"location":"geojson/#featurecollection","text":"A FeatureCollection is a collection of multiple features. FeatureCollection implements the Collection interface and can be used in any place that a collection can be used. Kotlin JSON val featureCollection = FeatureCollection ( pointFeature ) featureCollection . forEach { feature -> // ... } { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] }, \"properties\" : { \"size\" : 9999 } } ] }","title":"FeatureCollection"},{"location":"geojson/#boundingbox","text":"The BoundingBox class is used to represent the bounding boxes that can be set for any GeoJson object. Like the Position class, bounding boxes are backed by a DoubleArray with each component accessible by its propery ( southwest and northeast ). Bounding boxes also support destructuring. Kotlin JSON val bbox = BoundingBox ( west = 11.6 , south = 45.1 , east = 12.7 , north = 45.7 ) val ( southwest , northeast ) = bbox // Two Positions [ 11.6 , 45.1 , 12.7 , 45.7 ]","title":"BoundingBox"},{"location":"geojson/#serialization","text":"","title":"Serialization"},{"location":"geojson/#to-json","text":"Any GeoJson object can be serialized to a JSON string using the json() function. This function converts the object to JSON using string concatenation and is therefore very fast. Kotlin val featureCollection : FeatureCollection = getFeatureCollection () val json = featureCollection . json () println ( json ) Spatial-K is also fully compatible with kotlinx.serialization to allow for integration into more complex models, however this is much slower. For encoding directly to JSON strings, prefer to use the json() function.","title":"To Json"},{"location":"geojson/#from-json","text":"The fromJson and fromJsonOrNull companion (or static) functions are available on each GeoJson class to decode each type of object from a JSON string. Kotlin Java // Throws exception if the JSON cannot be deserialized to a Point val myPoint = Point . fromJson ( \"{...geojson...}\" ) // Returns null if an error occurs val nullable = Point . fromJsonOrNull ( \"{...not a point...}\" ) // Throws exception if the JSON cannot be deserialized to a Point var myPoint = Point . fromJson ( \"{...geojson...}\" ) // Returns null if an error occurs var nullable = Point . fromJsonOrNull ( \"{...not a point...}\" ) Like with encoding, Spatial-K objects can also be decoded using kotlinx.serialization . Kotlin val feature : Feature = Json . decodeFromString ( Feature . serializer (), \"{...feature...}\" )","title":"From Json"},{"location":"geojson/#geojson-dsl","text":"It's recommended to construct GeoJson objects in-code using the GeoJson DSL.","title":"GeoJson DSL"},{"location":"geojson/#positions","text":"Convenience functions to construct latitude/longitude Position instances is included. These functions will check for valid latitude and longitude values and will throw an IllegalArgumentException otherwise. Kotlin JSON lngLat ( longitude = - 75.0 , latitude = 45.0 ) // Throws exception!! lngLat ( longitude = - 565.0 , latitude = 45.0 ) [ -75.0 , 45.0 ]","title":"Positions"},{"location":"geojson/#geometry_1","text":"Each geometry type has a corresponding DSL. A GeoJson object's bbox value can be assigned in any of the DSLs.","title":"Geometry"},{"location":"geojson/#point_1","text":"Kotlin JSON point ( longitude = - 75.0 , latitude = 45.0 , altitude = 100.0 ) // Or... point ( Position ( 12.5 , 35.9 )) { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 , 100.0 ] }","title":"Point"},{"location":"geojson/#multipoint_1","text":"The MultiPoint DSL creates a MultiPoint from many Point s, or by using the unary plus operator to add Position instances as positions in the geometry. Point geometries can also be added to the multi point using the unary plus operator. Kotlin JSON val myPoint = Point ( 88.0 , 34.0 ) multiPoint { point ( - 75.0 , 45.0 ) + lngLat ( - 78.0 , 44.0 ) + myPoint } { \"type\" : \"MultiPoint\" , \"coordinates\" : [ [ -75.0 , 45.0 ], [ -78.0 , 44.0 ], [ 88.0 , 34.0 ] ] }","title":"MultiPoint"},{"location":"geojson/#linestring_1","text":"A LineString contains main points. Like with MultiPoint , a LineString can also be built using the unary plus operator to add positions as part of the line. The order in which positions are added to the LineString is the order that the LineString will follow. Kotlin JSON lineString { point ( 45.0 , 45.0 ) point ( 0.0 , 0.0 ) } { \"type\" : \"LineString\" , \"coordinates\" : [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]] }","title":"LineString"},{"location":"geojson/#multilinestring_1","text":"The MultiLineString DSL uses the unary plus operator to add multiple line strings. The LineString DSL can be used to create LineString objects to add. Kotlin JSON val simpleLine = lineString { point ( 45.0 , 45.0 ) point ( 0.0 , 0.0 ) } multiLineString { + simpleLine // Inline LineString creation lineString { point ( 44.4 , 55.5 ) point ( 55.5 , 66.6 ) } } { \"type\" : \"MultiLineString\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]], [[ 44.4 , 55.5 ], [ 55.5 , 66.6 ]] ] }","title":"MultiLineString"},{"location":"geojson/#polygon_1","text":"The Polygon DSL is used by specifying linear rings that make up the polygon's shape and holes. The first ring is the exterior ring with four or more positions. The last position must be the same as the first position. All ring s that follow will represent interior rings (i.e. holes) in the polygon. For convenience, the complete() function can be used to \"complete\" a ring. It adds the last position in the ring by copying the first position that was added. Kotlin JSON val simpleLine = lineString { point ( 45.0 , 45.0 ) point ( 0.0 , 0.0 ) } polygon { ring { // LineStrings can be used as part of a ring + simpleLine point ( 12.0 , 12.0 ) complete () } ring { point ( 4.0 , 4.0 ) point ( 2.0 , 2.0 ) point ( 3.0 , 3.0 ) complete () } } { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ] }","title":"Polygon"},{"location":"geojson/#multipolygon_1","text":"Like with previous \"Multi\" geometries, the unary plus operator is used to add multiple Polygon objects. The Polygon DSL can also be used here. Kotlin JSON val simplePolygon = previousExample () multiPolygon { + simplePolygon polygon { ring { point ( 12.0 , 0.0 ) point ( 0.0 , 12.0 ) point ( - 12.0 , 0.0 ) point ( 5.0 , 5.0 ) complete () } } } { \"type\" : \"MultiPolygon\" , \"coordinates\" : [ [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ], [ [[ 12.0 , 0.0 ], [ 0.0 , 12.0 ], [ -12.0 , 0.0 ], [ 5.0 , 5.0 ], [ 12.0 , 0.0 ]] ] ] }","title":"MultiPolygon"},{"location":"geojson/#geometry-collection","text":"The unary plus operator can be used to add any geometry instance to a GeometryCollection . Kotlin JSON val simplePoint : Point = previousPoint () val simpleLine : LineString = previousLineString () val simplePolygon : Polygon = previousPolygon () geometryCollection { + simplePoint + simpleLine + simplePolygon } { \"type\" : \"GeometryCollection\" , \"geometries\" : [ { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 , 100.0 ] }, { \"type\" : \"LineString\" , \"coordinates\" : [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]] }, { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ] } ] }","title":"Geometry Collection"},{"location":"geojson/#feature_1","text":"The Feature DSL can construct a Feature object with a geometry, a bounding box, and an id. Properties can be specified in the PropertiesBuilder block by calling put(key, value) to add properties. Kotlin JSON feature ( geometry = point ( - 75.0 , 45.0 ), id = \"point1\" , bbox = BoundingBox ( - 76.9 , 44.1 , - 74.2 , 45.7 )) { put ( \"name\" , \"Hello World\" ) put ( \"value\" , 13 ) put ( \"cool\" , true ) } { \"type\" : \"Feature\" , \"id\" : \"point1\" , \"bbox\" : [ -76.9 , 44.1 , -74.2 , 45.7 ], \"properties\" : { \"name\" : \"Hello World\" , \"value\" : 13 , \"cool\" : true }, \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 ] } }","title":"Feature"},{"location":"geojson/#feature-collection","text":"A FeatureCollection is constructed by adding multiple Feature objects using the unary plus operator. Kotlin JSON featureCollection { feature ( geometry = point ( - 75.0 , 45.0 )) } { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 ] }, \"properties\" : {} } ] }","title":"Feature Collection"},{"location":"ported-functions/","text":"Ported Functions The following functions have been ported as of version 0.2.0 of this library. You can view porting progress for the next release here . Measurement along area bbox bboxPolygon bearing center centerOfMass destination distance envelope length midpoint pointOnFeature polygonTangents pointToLineDistance rhumbBearing rhumbDestination rhumbDistance square greatCircle Coordinate Mutation cleanCoords flip rewind round Use round or Math.round from the standard library instead. truncate Transformation bboxClip bezierSpline buffer circle clone concave convex difference dissolve intersect lineOffset simplify tessellate transformRotate transformTranslate transformScale union voronoi Feature Conversion combine explode flatten lineToPolygon polygonize polygonToLine Miscellaneous kinks lineArc lineChunk lineIntersect Partially implemented. lineOverlap lineSegment lineSlice lineSliceAlong lineSplit mask nearestPointOnLine sector shortestPath unkinkPolygon Helper Use the GeoJson DSL instead. Random randomPosition randomPoint randomLineString randomPolygon Data sample Interpolation interpolate isobands isolines planepoint tin Joins pointsWithinPolygon tag Grids hexGrid pointGrid squareGrid triangleGrid Classification nearestPoint Aggregation collect clustersDbscan clustersKmeans Meta coordAll coordEach coordReduce featureEach featureReduce flattenEach flattenReduce getCoord getCoords getGeom getType geomEach geomReduce propEach segmentEach segmentReduce getCluster clusterEach clusterReduce Assertations collectionOf containsNumber geojsonType featureOf Booleans booleanClockwise booleanContains booleanCrosses booleanDisjoint booleanEqual booleanOverlap booleanParallel booleanPointInPolygon booleanPointOnLine booleanWithin Unit Conversion bearingToAzimuth convertArea convertLength degreesToRadians lengthToRadians lengthToDegrees radiansToLength radiansToDegrees toMercator toWgs84","title":"Ported Functions"},{"location":"ported-functions/#ported-functions","text":"The following functions have been ported as of version 0.2.0 of this library. You can view porting progress for the next release here .","title":"Ported Functions"},{"location":"ported-functions/#measurement","text":"along area bbox bboxPolygon bearing center centerOfMass destination distance envelope length midpoint pointOnFeature polygonTangents pointToLineDistance rhumbBearing rhumbDestination rhumbDistance square greatCircle","title":"Measurement"},{"location":"ported-functions/#coordinate-mutation","text":"cleanCoords flip rewind round Use round or Math.round from the standard library instead. truncate","title":"Coordinate Mutation"},{"location":"ported-functions/#transformation","text":"bboxClip bezierSpline buffer circle clone concave convex difference dissolve intersect lineOffset simplify tessellate transformRotate transformTranslate transformScale union voronoi","title":"Transformation"},{"location":"ported-functions/#feature-conversion","text":"combine explode flatten lineToPolygon polygonize polygonToLine","title":"Feature Conversion"},{"location":"ported-functions/#miscellaneous","text":"kinks lineArc lineChunk lineIntersect Partially implemented. lineOverlap lineSegment lineSlice lineSliceAlong lineSplit mask nearestPointOnLine sector shortestPath unkinkPolygon","title":"Miscellaneous"},{"location":"ported-functions/#helper","text":"Use the GeoJson DSL instead.","title":"Helper"},{"location":"ported-functions/#random","text":"randomPosition randomPoint randomLineString randomPolygon","title":"Random"},{"location":"ported-functions/#data","text":"sample","title":"Data"},{"location":"ported-functions/#interpolation","text":"interpolate isobands isolines planepoint tin","title":"Interpolation"},{"location":"ported-functions/#joins","text":"pointsWithinPolygon tag","title":"Joins"},{"location":"ported-functions/#grids","text":"hexGrid pointGrid squareGrid triangleGrid","title":"Grids"},{"location":"ported-functions/#classification","text":"nearestPoint","title":"Classification"},{"location":"ported-functions/#aggregation","text":"collect clustersDbscan clustersKmeans","title":"Aggregation"},{"location":"ported-functions/#meta","text":"coordAll coordEach coordReduce featureEach featureReduce flattenEach flattenReduce getCoord getCoords getGeom getType geomEach geomReduce propEach segmentEach segmentReduce getCluster clusterEach clusterReduce","title":"Meta"},{"location":"ported-functions/#assertations","text":"collectionOf containsNumber geojsonType featureOf","title":"Assertations"},{"location":"ported-functions/#booleans","text":"booleanClockwise booleanContains booleanCrosses booleanDisjoint booleanEqual booleanOverlap booleanParallel booleanPointInPolygon booleanPointOnLine booleanWithin","title":"Booleans"},{"location":"ported-functions/#unit-conversion","text":"bearingToAzimuth convertArea convertLength degreesToRadians lengthToRadians lengthToDegrees radiansToLength radiansToDegrees toMercator toWgs84","title":"Unit Conversion"},{"location":"turf/","text":"Turf Turfjs is a spatial analysis library for JavaScript applications and the turf module contains a Kotlin port of it with support for Kotlin Multiplatform projects. This module makes use of the classes defined in the geojson module as the GeoJson inputs to many of the turf functions. The documentation for the ported functions can be found in the API docs , while more details on each function can be found on the Turfjs site. Installation Kotlin Groovy dependencies { implementation ( \"io.github.dellisd.spatialk:turf:<version>\" ) } dependencies { implementation \"io.github.dellisd.spatialk:turf:<version>\" } Example Turf functions are available as top-level functions in Kotlin, or as static member functions in Java. Kotlin val point = LngLat ( - 75.0 , 45.0 ) val ( longitude , latitude ) = destination ( point , 100.0 , 0.0 ) Turf Functions A list of all turf functions and their current status in the port can be found on this page . Units of Measurement Units of measurement are represented using the Units enum. These enum values can be passed into functions to specify the units used by other values passed into the function. Kotlin val result = convertLength ( 12.5 , from = Units . Kilometers , to = Units . Miles ) Not all units are valid for every function. For example: acres cannot be used as a measure of distance. Calling a function like convertLength with Units.Acres as one of the arguments will cause an IllegalArgumentException .","title":"Overview"},{"location":"turf/#turf","text":"Turfjs is a spatial analysis library for JavaScript applications and the turf module contains a Kotlin port of it with support for Kotlin Multiplatform projects. This module makes use of the classes defined in the geojson module as the GeoJson inputs to many of the turf functions. The documentation for the ported functions can be found in the API docs , while more details on each function can be found on the Turfjs site.","title":"Turf"},{"location":"turf/#installation","text":"Kotlin Groovy dependencies { implementation ( \"io.github.dellisd.spatialk:turf:<version>\" ) } dependencies { implementation \"io.github.dellisd.spatialk:turf:<version>\" }","title":"Installation"},{"location":"turf/#example","text":"Turf functions are available as top-level functions in Kotlin, or as static member functions in Java. Kotlin val point = LngLat ( - 75.0 , 45.0 ) val ( longitude , latitude ) = destination ( point , 100.0 , 0.0 )","title":"Example"},{"location":"turf/#turf-functions","text":"A list of all turf functions and their current status in the port can be found on this page .","title":"Turf Functions"},{"location":"turf/#units-of-measurement","text":"Units of measurement are represented using the Units enum. These enum values can be passed into functions to specify the units used by other values passed into the function. Kotlin val result = convertLength ( 12.5 , from = Units . Kilometers , to = Units . Miles ) Not all units are valid for every function. For example: acres cannot be used as a measure of distance. Calling a function like convertLength with Units.Acres as one of the arguments will cause an IllegalArgumentException .","title":"Units of Measurement"}]}